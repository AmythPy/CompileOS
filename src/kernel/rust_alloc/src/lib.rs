// src/kernel/rust_alloc/src/lib.rs\n#![no_std]\n#![feature(alloc_error_handler)]\n\nextern crate alloc;\n\nuse core::alloc::{GlobalAlloc, Layout};\nuse core::ptr::null_mut;\n\n// Simple bump allocator for kernel heap\npub struct BumpAllocator {\n    heap_start: usize,\n    heap_end: usize,\n    next: usize,\n}\n\nimpl BumpAllocator {\n    pub const fn new(heap_start: usize, heap_size: usize) -> Self {\n        Self {\n            heap_start,\n            heap_end: heap_start + heap_size,\n            next: heap_start,\n        }\n    }\n}\n\nunsafe impl GlobalAlloc for BumpAllocator {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        let alloc_start = self.next;\n        let alloc_end = alloc_start + layout.size();\n        \n        if alloc_end > self.heap_end {\n            return null_mut();\n        }\n        \n        self.next = alloc_end;\n        alloc_start as *mut u8\n    }\n    \n    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {\n        // No-op for bump allocator\n    }\n}\n\n#[global_allocator]\nstatic ALLOCATOR: BumpAllocator = BumpAllocator::new(0x00400000, 0x00400000);\n\n#[alloc_error_handler]\nfn alloc_error_handler(layout: alloc::alloc::Layout) -> ! {\n    panic!(\"allocation error: {:?}\", layout)\n}\n\n// Safe wrapper for kmalloc-like functions\npub fn kmalloc(size: usize) -> Option<&'static mut [u8]> {\n    unsafe {\n        let ptr = ALLOCATOR.alloc(Layout::from_size_align(size, 4).unwrap());\n        if ptr.is_null() {\n            None\n        } else {\n            Some(core::slice::from_raw_parts_mut(ptr, size))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_kmalloc_simple() {\n        if let Some(mut mem) = kmalloc(128) {\n            // Write and read back\n            mem[0] = 42;\n            assert_eq!(mem[0], 42);\n        } else {\n            panic!("Allocation failed");\n        }\n    }\n}
